// CONFIGURAÇÃO FIREBASE
        const firebaseConfig = {
            apiKey: "AIzaSyDqYWTRKvmyjRM-to5raljV464Zvott4eM",
            authDomain: "whitermultiplayer.firebaseapp.com",
            databaseURL: "https://whitermultiplayer-default-rtdb.firebaseio.com/",
            projectId: "whitermultiplayer",
            storageBucket: "whitermultiplayer.firebasestorage.app",
            messagingSenderId: "859405698218",
            appId: "1:859405698218:web:44b4d4e4d1a96c93737cd3"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        let playerRef, roomRef, myID;

        // ESTADO DO JOGO
        const board = document.getElementById('game-board');
        let posX = 380, posY = 230, hp = 100, maxHp = 100, xp = 0, level = 1;
        let isPaused = false, isStarted = false, isDead = false;
        const keys = {}, enemies = [], bullets = [];

        function startGame() {
            const name = document.getElementById('username-input').value || "Player";
            document.getElementById('my-name-tag').innerText = name;
            document.getElementById('login-screen').style.display = 'none';
            board.style.display = 'block';
            document.getElementById('ui-stack').style.display = 'flex';
            isStarted = true;
            window.lastSpawn = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // MULTIPLAYER LÓGICA
        function connectToRoom(code) {
            if (playerRef) playerRef.remove();
            roomRef = db.ref('rooms/' + code);
            playerRef = roomRef.child('players').push();
            myID = playerRef.key;
            
            const myName = document.getElementById('my-name-tag').innerText;
            playerRef.set({ name: myName, x: posX, y: posY });
            playerRef.onDisconnect().remove();
            
            // ESCUTAR PAUSE GLOBAL
            roomRef.child('isPaused').on('value', snapshot => {
                isPaused = snapshot.val() || false;
                document.getElementById('config-panel').style.display = isPaused ? 'block' : 'none';
            });

            document.getElementById('room-info').innerText = "Sala: " + code;
            document.getElementById('room-display').innerText = "CÓDIGO: " + code;

            roomRef.child('players').on('value', snapshot => {
                const players = snapshot.val();
                document.querySelectorAll('.other-player').forEach(el => el.remove());
                for (let id in players) {
                    if (id === myID) continue;
                    const p = players[id];
                    const el = document.createElement('div');
                    el.className = 'other-player';
                    el.style.left = p.x + 'px'; el.style.top = p.y + 'px';
                    el.innerHTML = `<div class="player-name">${p.name}</div>`;
                    board.appendChild(el);
                }
            });
        }

        // CONTROLE DE PAUSE (SOMENTE ADM)
        function toggleMenu() {
            if(!isStarted) return;
            
            const myName = document.getElementById('my-name-tag').innerText;
            
            // Apenas o jogador com nome "Gusta" pode controlar o pause global
            // Mude "Gusta" para o nome que você usa no jogo
            if (myName === "Gusta" && roomRef) {
                roomRef.child('isPaused').set(!isPaused);
            } else if (!roomRef) {
                // Se estiver jogando Solo, o pause funciona normal
                isPaused = !isPaused;
                document.getElementById('config-panel').style.display = isPaused ? 'block' : 'none';
            }
        }

        function createRoom() {
            const code = Math.floor(100000 + Math.random() * 900000);
            connectToRoom(code);
        }

        function joinRoomPrompt() {
            const code = prompt("Código da sala:");
            if(code && code.length === 6) connectToRoom(code);
        }

        window.addEventListener('keydown', e => { 
            keys[e.key.toLowerCase()] = true; 
            if(e.key === 'Escape') toggleMenu();
        });
        window.addEventListener('keyup', e => delete keys[e.key.toLowerCase()]);

        board.addEventListener('mousedown', e => {
            if(!isStarted || isPaused || isDead) return;
            const rect = board.getBoundingClientRect();
            const angle = Math.atan2(e.clientY - rect.top - (posY + 20), e.clientX - rect.left - (posX + 20));
            createBullet(posX + 16, posY + 16, angle);
        });

        function createBullet(x, y, angle) {
            const bEl = document.createElement('div');
            bEl.className = 'bullet';
            board.appendChild(bEl);
            bullets.push({ el: bEl, x, y, vx: Math.cos(angle) * 10, vy: Math.sin(angle) * 10 });
        }

        function spawnEnemy() {
            const el = document.createElement('div');
            el.className = 'enemy';
            el.style.width = '30px'; el.style.height = '30px'; el.style.backgroundColor = '#2ecc71';
            let ex = Math.random() > 0.5 ? -40 : 840, ey = Math.random() * 500;
            board.appendChild(el);
            enemies.push({ el, x: ex, y: ey, hp: 2, speed: 1.5 + (level * 0.1) });
        }

        function gameLoop(time) {
            if (isStarted && !isPaused && !isDead) {
                if (time - (window.lastSpawn || 0) > 2000 - (level * 50)) {
                    spawnEnemy();
                    window.lastSpawn = time;
                }

                let moved = false;
                if (keys['w']) { posY -= 5; moved = true; }
                if (keys['s']) { posY += 5; moved = true; }
                if (keys['a']) { posX -= 5; moved = true; }
                if (keys['d']) { posX += 5; moved = true; }

                if (moved) {
                    posX = Math.max(0, Math.min(posX, 760));
                    posY = Math.max(0, Math.min(posY, 460));
                    const pEl = document.getElementById('player');
                    pEl.style.left = posX + 'px'; pEl.style.top = posY + 'px';
                    if (playerRef) playerRef.update({ x: posX, y: posY });
                }

                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.x += b.vx; b.y += b.vy;
                    b.el.style.left = b.x + 'px'; b.el.style.top = b.y + 'px';
                    if (b.x < -10 || b.x > 810 || b.y < -10 || b.y > 510) {
                        b.el.remove(); bullets.splice(i, 1);
                    }
                }

                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    const angle = Math.atan2(posY - e.y, posX - e.x);
                    e.x += Math.cos(angle) * e.speed;
                    e.y += Math.sin(angle) * e.speed;
                    e.el.style.left = e.x + 'px'; e.el.style.top = e.y + 'px';

                    if (Math.hypot(posX - e.x, posY - e.y) < 30) {
                        hp -= 0.5;
                        if (hp <= 0) { isDead = true; document.getElementById('game-over').style.display = 'block'; }
                    }

                    bullets.forEach((b, bi) => {
                        if (Math.hypot(b.x - e.x, b.y - e.y) < 25) {
                            e.hp--; b.el.remove(); bullets.splice(bi, 1);
                            if (e.hp <= 0) {
                                xp += 20; e.el.remove(); enemies.splice(i, 1);
                                if (xp >= level * 100) { level++; xp = 0; }
                            }
                        }
                    });
                }
            }
            document.getElementById('hp-bar-fill').style.width = hp + "%";
            document.getElementById('xp-val').innerText = xp;
            document.getElementById('lvl-val').innerText = level;
            requestAnimationFrame(gameLoop);
        }
